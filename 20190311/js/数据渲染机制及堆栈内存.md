# 机制&原理

## 数据渲染机制及堆栈内存

栈内存（作用域）作用：

- 提供一个供 js 代码自上而下执行的环境（代码都是在栈内存中执行）
- 由于基本数据类型值比较简单，它们都是直接在栈内存中开辟一个位置，把值直接存储进去的
  - =》当栈内存被销毁，存储的基本值也跟着销毁了

堆内存：引用值对应的空间

- 存储引用类型的值的（对象：键值对，函数：代码字符串）
  - =》当前堆内存销毁那么这个引用值彻底没了
  - =》堆内存的释放：当堆内存没有被任何的变量或者其他东西所占用的时候，浏览器会在空闲的时候，自主的进行内存回收，把所有不被占用的堆内存销毁掉（谷歌浏览器）（IE 浏览器内存的计数器）
  - xxx = null 通过空对象指针 null 可以让原始变量（或者其他东西）谁都不指向，那么原有被占用堆内存就没有被东西占用了，浏览器会销毁它

IE 浏览器的泄露问题：由于 IE 浏览器内存回收机制产生的

## 变量提升机制

变量提升只发生在当前作用域（eg：开始加载页面只对全局作用域下的进行提升，因为此时函数中存储的都是字符串）
在全局作用域下声明的函数或者变量是全局变量，同理，在私有作用域下声明的变量是私有变量

- 当栈内存（作用域）形成，JS 代码自上而下执行之前，浏览器首先会把所有带‘VAR/FUNCTION’关键字的进行提前声明或者定义，这种预先处理机制称之为'变量提升'
- 声明（dcelare）：var a /function sum (默认值 Undefined)
- 定义（defined）：a = 12 (定义其实就是赋值操作)

变量提升阶段

- 带 VAR 的只声明未定义
- 带 FUNCTION 的声明和赋值都完成了

## 原型链和原型链的查找机制

- 所有的函数数据类型都天生自带一个属性：`prototype`（原型），这个属性的值是一个对象，浏览器会默认给他开辟一个堆内存
- 在浏览器给 `prototype` 开辟的堆内存当中有一个天生自带的属性：constructor，这个属性存储的值是当前函数本身
- 每一个对象都有一个`__proto__`的属性,这个属性指向当前实例所属类的`prototype`(如果不能确定他是谁的实例，都是 object 的实例)
  每个类都把供实例调取的公共属性方法，存储到自己的原型上（原型 prototype 的作用就是存储一些公共的属性和方法，供他的实例调取使用）
  基类 Object 的原型上的`__proto__`指向 null，因为到最底层类，如果要指向也是指向自己本身，没意义

::: warning 原型链
原型链：它是一种基于`__proto__`向上查找的机制。当我们操作实例的某个属性或者方法的时候，首先找自己空间中私有的属性或者方法， 1.找到了，则结束查找，使用自己的私有的即可 2.没有找到,则基于`__proto__`找所属类的 prototype,如果找到就用这个共有的，如果没找到基于原型上的`__proto__`继续向上查找，一直找到 Object.prototype 的原型为止，如果再没有，操作的属性或者方法不存在
:::

## call

- [fn].call([this],[param]...)
  - fn.call:当前实例（函数 FN）通过原型链测查找机制，找到 Function.prototype 上的 call 方法 =>function call(){[native code]}
  - fn.call():把找到的 call 方法执行
    当 call 方法执行的时候内部处理了一些事情
    =》首先把要操作函数中的 this 关键字变为 CALL 方法第一个传递的实参值
    =》把 CALL 方法第二个及第二个实参获取到
    =》把要操作的函数执行，并且把第二个以后传递进来的实参传给操作的函数

## 箭头函数

- 箭头函数没有 arguments 但是可以基于...arg 获取实参集合（结果是一个数组）
- 箭头函数中没有自己的执行主体（THIS），它的 THIS 都是继承上下文中的 THIS

<!-- ## 重排（回流） 重绘 -->

## js 的同步编程和异步编程

同步编程：任务是按照顺序依次处理，当前这件事没有彻底做完，下一件事是执行不了的
异步编程：当前这件事情没有彻底做完，需要等待一段时间才能继续处理，此时我们不需要等，继续执行下面的任务，当后面的任务完成后，再去把彻底没完成的事情完成

【js 中的异步编程】

- 所有的事件绑定都是异步编程
- 所有的定时器都是异步编程
- AJAX 中一般都是用异步编程处理
- 回调函数也算是异步编程

浏览器如何规划同步异步机制的

- 浏览器是多线程的，JS 是单线程的（浏览器只给 JS 执行分配一个线程）
  - 进程：每一个应用程序都可以理解为一个进程（浏览器打开一个页面，就相当于开辟一个进程），在一个程序中（进程中）我们经常会同时干很多事情，此时我们可以分配多个线程去完成多项任务
- JS 在单线程中实现异步的机制，主要依赖于浏览器的任务队列完成的。浏览器中有两个任务队列（主任务队列、等待任务队列）

## 回调函数

**把一个函数 A 当作实参传递给另一个函数 B，在 B 方法执行的时候，把 A 执行了，我们把这种机制叫做‘回掉函数机制’**

- 根据需求回掉函数可以被执行 N 多次
- 不仅可以把回调函数执行，还可以给回调函数传递实参，这样在回调函数中设置形参（或者 `arguments`）接受即可
- 还可以改变回调函数中的 `this`指向
- 可以在宿主函数（它在那执行的，它的宿主函数就是谁）中接受回调函数执行的返回结果

```javascript
let fn = callback => {
  // =>callback：传递进来的函数
  //   callback && callback.call(obj,100, 200)
  //=>typeof callback === 'function'?callback():null
  let res = callback(10, 20)
  console.log(res)
}

fn((n, m) => {
  //=》this：window 回调函数中一般this都是window，除非宿主函数执行回调函数的时候把this特殊指向了（箭头函数除外，箭头函数的this是它上下文的）
  //   console.log(n, m)
  return n + m
})
```

## 事件的传播机制

冒泡传播：触发当前元素的某一个事件（点击事件）行为，不仅当前元素事件行为触发，而且其祖先元素的事件行为也会依次触发，这种机制就是‘事件冒泡传播机制’
